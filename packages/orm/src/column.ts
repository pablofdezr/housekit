
export type ColumnMeta = {
    isJson?: boolean;
    enumValues?: readonly string[];
    autoGenerate?: {
        type: 'uuid';
        version?: 1 | 3 | 4 | 5 | 6 | 7;
    };
    isPrimaryKey?: boolean;
    default?: any;
    defaultFn?: (row: Record<string, any>) => any;
    references?: {
        table: string;
        column: string;
        onDelete?: 'cascade' | 'set null' | 'restrict' | 'no action';
        onUpdate?: 'cascade' | 'set null' | 'restrict' | 'no action';
    };
    codec?: string;
    materialized?: string;
    alias?: string;
    defaultExpr?: string;
    comment?: string;
};

export class ClickHouseColumn<
    TType = any,
    TNotNull extends boolean = true,
    TAutoGenerated extends boolean = false
> {
    tableName?: string;
    constructor(
        public name: string,
        public type: string,
        public isNull = false,  // Columns are NOT NULL by default (isNull = false)
        public meta?: ColumnMeta
    ) { }

    clone<NTNotNull extends boolean = TNotNull, NAutoGenerated extends boolean = TAutoGenerated>(
        overrides: {
            name?: string;
            type?: string;
            isNull?: boolean;
            meta?: ColumnMeta;
        } = {}
    ): ClickHouseColumn<TType, NTNotNull, NAutoGenerated> {
        const clonedMeta = overrides.meta ?? (this.meta ? { ...this.meta } : undefined);
        const col = new ClickHouseColumn<TType, NTNotNull, NAutoGenerated>(
            overrides.name ?? this.name,
            overrides.type ?? this.type,
            overrides.isNull ?? this.isNull,
            clonedMeta
        );
        col.tableName = this.tableName;
        return col;
    }

    notNull(): ClickHouseColumn<TType, true, TAutoGenerated> {
        return this.clone<true, TAutoGenerated>({ isNull: false });
    }

    nullable(): ClickHouseColumn<TType, false, TAutoGenerated> {
        return this.clone<false, TAutoGenerated>({ isNull: true });
    }

    autoGenerate(options?: { version?: 1 | 3 | 4 | 5 | 6 | 7 }): ClickHouseColumn<TType, TNotNull, true> {
        if (this.type !== 'UUID') {
            throw new Error('autoGenerate() can only be used with UUID columns');
        }
        const version = options?.version || 4;
        const meta: ColumnMeta = { ...(this.meta ?? {}), autoGenerate: { type: 'uuid', version } };
        return this.clone<TNotNull, true>({ meta });
    }

    primaryKey(): ClickHouseColumn<TType, true, TAutoGenerated> {
        const meta: ColumnMeta = { ...(this.meta ?? {}), isPrimaryKey: true };
        return this.clone<true, TAutoGenerated>({ isNull: false, meta });
    }

    /**
     * Define a default value for the column. 
     * Can be a static value or a SQL expression like 'now()'.
     */
    default(value: any): ClickHouseColumn<TType, TNotNull, true> {
        const meta: ColumnMeta = { ...(this.meta ?? {}) };

        // Detect if value is a SQL expression or a literal
        if (typeof value === 'string') {
            // Check if it looks like a SQL expression (contains function calls, parentheses, etc.)
            const trimmed = value.trim();
            const isExpression =
                trimmed.includes('(') && trimmed.includes(')') || // Function calls like now()
                trimmed.match(/^[a-zA-Z_][a-zA-Z0-9_]*\s*\(/); // Function name followed by (

            if (isExpression) {
                meta.defaultExpr = trimmed;
                delete meta.default;
            } else {
                meta.default = value;
                delete meta.defaultExpr;
            }
        } else {
            meta.default = value;
            delete meta.defaultExpr;
        }
        return this.clone<TNotNull, true>({ meta });
    }

    references(
        getColumn: () => ClickHouseColumn,
        options?: {
            onDelete?: 'cascade' | 'set null' | 'restrict' | 'no action';
            onUpdate?: 'cascade' | 'set null' | 'restrict' | 'no action';
        }
    ) {
        const column = getColumn();
        const meta: ColumnMeta = {
            ...(this.meta ?? {}),
            references: {
                table: '', // Will be resolved later
                column: column.name,
                onDelete: options?.onDelete,
                onUpdate: options?.onUpdate,
            }
        };
        return this.clone({ meta });
    }

    /**
     * Add a comment to the column in the database.
     */
    comment(text: string) {
        const meta: ColumnMeta = { ...(this.meta ?? {}), comment: text };
        return this.clone({ meta });
    }

    alias(expression: string) {
        const meta: ColumnMeta = { ...(this.meta ?? {}), alias: expression };
        return this.clone({ meta });
    }

    /**
     * Apply a compression codec to this column.
     * Can be chained to apply multiple codecs (e.g., Delta then ZSTD).
     * 
     * @example
     * ```typescript
     * // Optimize for time-series
     * timestamp.codec('DoubleDelta').codec('ZSTD', 3)
     * // Optimize for metrics
     * value.codec('Gorilla')
     * ```
     */
    codec(type: 'ZSTD' | 'LZ4' | 'Delta' | 'DoubleDelta' | 'Gorilla' | 'None', level?: number) {
        const codecStr = level ? `${type}(${level})` : type;
        const meta: ColumnMeta = {
            ...(this.meta ?? {}),
            // Append if exists (chained codecs are comma-separated in ClickHouse)
            codec: this.meta?.codec ? `${this.meta.codec}, ${codecStr}` : codecStr
        };
        return this.clone({ meta });
    }

    /**
     * Calculates the column value on the client side before insertion.
     * Useful for UUIDs, hashes, or computations based on other fields.
     */
    $defaultFn(fn: (row: Record<string, any>) => any): ClickHouseColumn<TType, TNotNull, true> {
        const meta: ColumnMeta = { ...(this.meta ?? {}), defaultFn: fn };
        return this.clone<TNotNull, true>({ meta });
    }

    toSQL() {
        const isComposite = this.type.startsWith('Array(') || this.type.startsWith('Map(') || this.type.startsWith('Tuple(');
        const baseType = (this.isNull && !isComposite) ? `Nullable(${this.type})` : this.type;
        const clauses: string[] = [baseType];
        if (this.meta?.codec) {
            clauses.push(`CODEC(${this.meta.codec})`);
        }
        if (this.meta?.defaultExpr) {
            clauses.push(`DEFAULT ${this.meta.defaultExpr}`);
        } else if (this.meta?.default !== undefined) {
            // Convert default value to SQL literal
            const defaultValue = this.meta.default;
            let sqlValue: string;
            if (typeof defaultValue === 'string') {
                sqlValue = `'${defaultValue.replace(/'/g, "''")}'`; // Escape single quotes
            } else if (typeof defaultValue === 'number') {
                sqlValue = String(defaultValue);
            } else if (typeof defaultValue === 'boolean') {
                sqlValue = defaultValue ? '1' : '0';
            } else if (defaultValue === null) {
                sqlValue = 'NULL';
            } else {
                // For other types, try to stringify (e.g., Date objects)
                sqlValue = `'${String(defaultValue).replace(/'/g, "''")}'`;
            }
            clauses.push(`DEFAULT ${sqlValue}`);
        }
        if (this.meta?.materialized) {
            clauses.push(`MATERIALIZED ${this.meta.materialized}`);
        }
        if (this.meta?.alias) {
            clauses.push(`ALIAS ${this.meta.alias}`);
        }
        if (this.meta?.comment) {
            // Escape single quotes in comment
            const escapedComment = this.meta.comment.replace(/'/g, "''");
            clauses.push(`COMMENT '${escapedComment}'`);
        }
        return clauses.join(' ');
    }
}
